<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ù…Ù†Ø¸Ù… Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ</title>
<style>
  body {
    font-family: "Tahoma", sans-serif;
    background: #f2f2f2;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
  }
  header {
    background: #0078d7;
    color: #fff;
    padding: 10px 20px;
    font-size: 22px;
    text-align: center;
  }
  #main {
    display: flex;
    flex-direction: row;
    height: calc(100vh - 50px);
  }
  #channels {
    width: 220px;
    background: #e7e7e7;
    padding: 10px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  #channels button {
    width: 100%;
    padding: 8px;
    margin-bottom: 6px;
    border: none;
    background: #ddd;
    cursor: pointer;
    font-size: 14px;
    border-radius: 6px;
  }
  #channels button.active {
    background: #0078d7;
    color: #fff;
  }
  #tasks {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
  }
  .task {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #fff;
    padding: 8px 10px;
    margin-bottom: 6px;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    touch-action: none;
  }
  .task.dragging {
    opacity: 0.5;
  }
  .task button {
    margin-left: 6px;
  }
  #controls {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  #controls button {
    padding: 10px;
    font-size: 14px;
    border: none;
    background: #0078d7;
    color: #fff;
    border-radius: 8px;
    cursor: pointer;
  }
  #prompt {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.4);
    z-index: 9999;
  }
  #promptBox {
    background: #fff;
    padding: 20px;
    border-radius: 10px;
    width: 90%;
    max-width: 320px;
    text-align: center;
  }
  #promptBox input {
    width: 90%;
    padding: 8px;
    font-size: 14px;
    margin-bottom: 10px;
  }
  #promptButtons {
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  #promptButtons button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    background: #0078d7;
    color: #fff;
    cursor: pointer;
  }
  #promptButtons button.cancel {
    background: #888;
  }
</style>
</head>
<body>
<header>Ù…Ù†Ø¸Ù… Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ</header>
<div id="main">
  <div id="channels"></div>
  <div id="tasks"></div>
</div>

<div id="controls">
  <button id="addTask">â• Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø©</button>
  <button id="addChannel">ğŸ“ Ù‚Ù†Ø§Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
  <button id="resetAll">â™»ï¸ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·</button>
</div>

<div id="prompt">
  <div id="promptBox">
    <p id="promptText"></p>
    <input id="promptInput" type="text" placeholder="">
    <div id="promptButtons"></div>
  </div>
</div>

<script>
const channelsDiv = document.getElementById("channels");
const tasksDiv = document.getElementById("tasks");
const promptOverlay = document.getElementById("prompt");
const promptText = document.getElementById("promptText");
const promptInput = document.getElementById("promptInput");
const promptButtons = document.getElementById("promptButtons");

let channels = JSON.parse(localStorage.getItem("channels") || "[]");
let selectedChannel = localStorage.getItem("selectedChannel") || null;
let dragTask = null;
let touchStartY = 0;
let dragging = false;

function saveData() {
  localStorage.setItem("channels", JSON.stringify(channels));
  if (selectedChannel) localStorage.setItem("selectedChannel", selectedChannel);
}

function showPrompt(text, withInput, callback, yesNo = false) {
  promptText.textContent = text;
  promptOverlay.style.display = "flex";
  promptInput.style.display = withInput ? "block" : "none";
  promptButtons.innerHTML = "";

  if (withInput) {
    const confirmBtn = document.createElement("button");
    confirmBtn.textContent = "ØªØ£ÙƒÙŠØ¯";
    confirmBtn.onclick = () => { closePrompt(); callback(promptInput.value.trim()); };
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "Ø¥Ù„ØºØ§Ø¡";
    cancelBtn.className = "cancel";
    cancelBtn.onclick = closePrompt;
    promptButtons.append(confirmBtn, cancelBtn);
    promptInput.value = "";
    promptInput.focus();
    promptInput.onkeydown = e => {
      if (e.key === "Enter") {
        closePrompt();
        callback(promptInput.value.trim());
      }
    };
  } else if (yesNo) {
    const yes = document.createElement("button");
    yes.textContent = "Ù†Ø¹Ù…";
    yes.onclick = () => { closePrompt(); callback(true); };
    const no = document.createElement("button");
    no.textContent = "Ù„Ø§";
    no.className = "cancel";
    no.onclick = () => { closePrompt(); callback(false); };
    promptButtons.append(yes, no);
  }
}

function closePrompt() {
  promptOverlay.style.display = "none";
}

function renderChannels() {
  channelsDiv.innerHTML = "";
  channels.forEach(ch => {
    const btn = document.createElement("button");
    btn.textContent = ch.name;
    if (ch.id === selectedChannel) btn.classList.add("active");
    btn.onclick = () => {
      selectedChannel = ch.id;
      saveData();
      renderChannels();
      renderTasks();
    };
    btn.oncontextmenu = e => {
      e.preventDefault();
      showPrompt("Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù‚Ù†Ø§Ø©:", true, newName => {
        if (newName) {
          ch.name = newName;
          saveData();
          renderChannels();
        }
      });
    };
    channelsDiv.appendChild(btn);
  });
}

function renderTasks() {
  tasksDiv.innerHTML = "";
  const channel = channels.find(c => c.id === selectedChannel);
  if (!channel) return;
  channel.tasks.forEach(task => {
    const div = document.createElement("div");
    div.className = "task";
    div.draggable = true;
    div.innerHTML = `<span>${task.name}</span>`;
    const btnBox = document.createElement("div");

    const checkBtn = document.createElement("button");
    checkBtn.textContent = task.done ? "âœ…" : "â¬œ";
    checkBtn.onclick = e => {
      e.stopPropagation();
      task.done = !task.done;
      saveData();
      renderTasks();
    };

    const renameBtn = document.createElement("button");
    renameBtn.textContent = "âœï¸";
    renameBtn.onclick = e => {
      e.stopPropagation();
      showPrompt("Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù‡Ù…Ø©:", true, newName => {
        if (newName) {
          task.name = newName;
          saveData();
          renderTasks();
        }
      });
    };

    btnBox.append(checkBtn, renameBtn);
    div.appendChild(btnBox);

    // Mobile + desktop drag logic
    div.addEventListener("dragstart", () => {
      dragTask = task;
      setTimeout(() => div.classList.add("dragging"), 0);
    });
    div.addEventListener("dragend", () => {
      dragTask = null;
      div.classList.remove("dragging");
      saveData();
    });

    div.addEventListener("touchstart", e => {
      touchStartY = e.touches[0].clientY;
      dragging = false;
    });
    div.addEventListener("touchmove", e => {
      if (Math.abs(e.touches[0].clientY - touchStartY) > 10) dragging = true;
    });
    div.addEventListener("touchend", e => {
      if (!dragging) {
        // not dragging, ignore
      }
    });

    tasksDiv.appendChild(div);
  });

  tasksDiv.addEventListener("dragover", e => {
    e.preventDefault();
    const afterElement = getDragAfterElement(tasksDiv, e.clientY);
    const channel = channels.find(c => c.id === selectedChannel);
    if (!channel || !dragTask) return;
    const index = channel.tasks.indexOf(dragTask);
    channel.tasks.splice(index, 1);
    const newIndex = afterElement
      ? channel.tasks.findIndex(t => t.name === afterElement.querySelector("span").textContent)
      : channel.tasks.length;
    channel.tasks.splice(newIndex, 0, dragTask);
    renderTasks();
  });
}

function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll(".task:not(.dragging)")];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

document.getElementById("addTask").onclick = () => {
  if (!selectedChannel) return alert("Ø§Ø®ØªØ± Ù‚Ù†Ø§Ø© Ø£ÙˆÙ„Ø§Ù‹!");
  showPrompt("Ø§Ø³Ù… Ø§Ù„Ù…Ù‡Ù…Ø©:", true, val => {
    if (val) {
      const ch = channels.find(c => c.id === selectedChannel);
      ch.tasks.push({ name: val, done: false });
      saveData();
      renderTasks();
    }
  });
};

document.getElementById("addChannel").onclick = () => {
  showPrompt("Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©:", true, val => {
    if (val) {
      const newCh = { id: Date.now().toString(), name: val, tasks: [] };
      channels.push(newCh);
      selectedChannel = newCh.id;
      saveData();
      renderChannels();
      renderTasks();
    }
  });
};

document.getElementById("resetAll").onclick = () => {
  showPrompt("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·ØŸ", false, confirmed => {
    if (confirmed) {
      channels = [];
      selectedChannel = null;
      saveData();
      renderChannels();
      renderTasks();
    }
  }, true);
};

renderChannels();
renderTasks();
</script>
</body>
</html>
